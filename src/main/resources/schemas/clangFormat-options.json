{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Clang Format Style Schema",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "BasedOnStyle": {
      "x-intellij-html-description": "<a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BasedOnStyle%20('>Documentation</a>\nThe style used for all options not specifically set in the configuration.",
      "type": "string",
      "enum": [
        "LLVM",
        "Google",
        "Chromium",
        "Mozilla",
        "WebKit",
        "Microsoft",
        "GNU",
        "InheritParentConfig"
      ],
      "x-intellij-enum-metadata": {
        "LLVM": {
          "description": "A style complying with the LLVM coding standards"
        },
        "Google": {
          "description": "A style complying with Google's C++ style guide"
        },
        "Chromium": {
          "description": "A style complying with Chromium's style guide"
        },
        "Mozilla": {
          "description": "A style complying with Mozilla's style guide"
        },
        "WebKit": {
          "description": "A style complying with WebKit's style guide"
        },
        "Microsoft": {
          "description": "A style complying with Microsoft's style guide"
        },
        "GNU": {
          "description": "A style complying with the GNU coding standards"
        }
      },
      "x-romolo-link": "https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BasedOnStyle%20("
    },
    "AccessModifierOffset": {
      "type": "number",
      "x-intellij-html-description": "<p>The extra indent or outdent of access modifiers, e.g. ``public:``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AccessModifierOffset%20('>Documentation</a>\n"
    },
    "AlignAfterOpenBracket": {
      "type": "string",
      "enum": [
        "Align",
        "DontAlign",
        "AlwaysBreak",
        "BlockIndent"
      ],
      "x-intellij-enum-metadata": {
        "Align": {
          "description": "Align parameters on the open bracket, e.g.:"
        },
        "DontAlign": {
          "description": "Don't align, instead use ``ContinuationIndentWidth``, e.g.:"
        },
        "AlwaysBreak": {
          "description": "Always break after an open bracket, if the parameters don't fit"
        },
        "BlockIndent": {
          "description": "Always break after an open bracket, if the parameters don't fit"
        }
      },
      "x-intellij-html-description": "<p>If ``true``, horizontally aligns arguments after an open bracket.\n<p>This applies to round brackets (parentheses), angle brackets and square\nbrackets.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignAfterOpenBracket%20('>Documentation</a>\n"
    },
    "AlignArrayOfStructures": {
      "type": "string",
      "enum": [
        "Left",
        "Right",
        "None"
      ],
      "x-intellij-enum-metadata": {
        "Left": {
          "description": "Align array column and left justify the columns e.g.:"
        },
        "Right": {
          "description": "Align array column and right justify the columns e.g.:"
        },
        "None": {
          "description": "Don't align array initializer columns."
        }
      },
      "x-intellij-html-description": "<p>if not ``None``, when using initialization for an array of structs\naligns the fields into columns.\n<p>NOTE: As of clang-format 15 this option only applied to arrays with equal\nnumber of columns per row.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignArrayOfStructures%20('>Documentation</a>\n"
    },
    "AlignConsecutiveAssignments": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Enabled": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether aligning is enabled.\n<p>.. code-block:: c++\n<p>  #define SHORT_NAME       42\n  #define LONGER_NAME      0x007f\n  #define EVEN_LONGER_NAME (2)\n  #define foo(x)           (x * x)\n  #define bar(y, z)        (y + z)\n<p>  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int aaaa : 1;\n  int b    : 12;\n  int ccc  : 8;\n<p>  int         aaaa = 12;\n  float       b = 23;\n  std::string ccc;"
        },
        "AcrossEmptyLines": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across empty lines.\n<p>.. code-block:: c++\n<p>  true:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d            = 3;\n<p>  false:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d = 3;"
        },
        "AcrossComments": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across comments.\n<p>.. code-block:: c++\n<p>  true:\n  int d    = 3;\n  /* A comment. */\n  double e = 4;\n<p>  false:\n  int d = 3;\n  /* A comment. */\n  double e = 4;"
        },
        "AlignCompound": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether compound assignments\nlike ``+=`` are aligned along with ``=``.\n<p>.. code-block:: c++\n<p>  true:\n  a   &= 2;\n  bbb  = 2;\n<p>  false:\n  a &= 2;\n  bbb = 2;"
        },
        "PadOperators": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether short assignment\noperators are left-padded to the same length as long ones in order to\nput all assignment operators to the right of the left hand side.\n<p>.. code-block:: c++\n<p>  true:\n  a   >>= 2;\n  bbb   = 2;\n<p>  a     = 2;\n  bbb >>= 2;\n<p>  false:\n  a >>= 2;\n  bbb = 2;\n<p>  a     = 2;\n  bbb >>= 2;"
        }
      },
      "x-intellij-html-description": "<p>Style of aligning consecutive assignments.\n<p>``Consecutive`` will result in formattings like:\n<p>.. code-block:: c++\n<p>  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignConsecutiveAssignments%20('>Documentation</a>\n"
    },
    "AlignConsecutiveBitFields": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Enabled": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether aligning is enabled.\n<p>.. code-block:: c++\n<p>  #define SHORT_NAME       42\n  #define LONGER_NAME      0x007f\n  #define EVEN_LONGER_NAME (2)\n  #define foo(x)           (x * x)\n  #define bar(y, z)        (y + z)\n<p>  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int aaaa : 1;\n  int b    : 12;\n  int ccc  : 8;\n<p>  int         aaaa = 12;\n  float       b = 23;\n  std::string ccc;"
        },
        "AcrossEmptyLines": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across empty lines.\n<p>.. code-block:: c++\n<p>  true:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d            = 3;\n<p>  false:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d = 3;"
        },
        "AcrossComments": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across comments.\n<p>.. code-block:: c++\n<p>  true:\n  int d    = 3;\n  /* A comment. */\n  double e = 4;\n<p>  false:\n  int d = 3;\n  /* A comment. */\n  double e = 4;"
        },
        "AlignCompound": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether compound assignments\nlike ``+=`` are aligned along with ``=``.\n<p>.. code-block:: c++\n<p>  true:\n  a   &= 2;\n  bbb  = 2;\n<p>  false:\n  a &= 2;\n  bbb = 2;"
        },
        "PadOperators": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether short assignment\noperators are left-padded to the same length as long ones in order to\nput all assignment operators to the right of the left hand side.\n<p>.. code-block:: c++\n<p>  true:\n  a   >>= 2;\n  bbb   = 2;\n<p>  a     = 2;\n  bbb >>= 2;\n<p>  false:\n  a >>= 2;\n  bbb = 2;\n<p>  a     = 2;\n  bbb >>= 2;"
        }
      },
      "x-intellij-html-description": "<p>Style of aligning consecutive bit fields.\n<p>``Consecutive`` will align the bitfield separators of consecutive lines.\nThis will result in formattings like:\n<p>.. code-block:: c++\n<p>  int aaaa : 1;\n  int b    : 12;\n  int ccc  : 8;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignConsecutiveBitFields%20('>Documentation</a>\n"
    },
    "AlignConsecutiveDeclarations": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Enabled": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether aligning is enabled.\n<p>.. code-block:: c++\n<p>  #define SHORT_NAME       42\n  #define LONGER_NAME      0x007f\n  #define EVEN_LONGER_NAME (2)\n  #define foo(x)           (x * x)\n  #define bar(y, z)        (y + z)\n<p>  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int aaaa : 1;\n  int b    : 12;\n  int ccc  : 8;\n<p>  int         aaaa = 12;\n  float       b = 23;\n  std::string ccc;"
        },
        "AcrossEmptyLines": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across empty lines.\n<p>.. code-block:: c++\n<p>  true:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d            = 3;\n<p>  false:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d = 3;"
        },
        "AcrossComments": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across comments.\n<p>.. code-block:: c++\n<p>  true:\n  int d    = 3;\n  /* A comment. */\n  double e = 4;\n<p>  false:\n  int d = 3;\n  /* A comment. */\n  double e = 4;"
        },
        "AlignCompound": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether compound assignments\nlike ``+=`` are aligned along with ``=``.\n<p>.. code-block:: c++\n<p>  true:\n  a   &= 2;\n  bbb  = 2;\n<p>  false:\n  a &= 2;\n  bbb = 2;"
        },
        "PadOperators": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether short assignment\noperators are left-padded to the same length as long ones in order to\nput all assignment operators to the right of the left hand side.\n<p>.. code-block:: c++\n<p>  true:\n  a   >>= 2;\n  bbb   = 2;\n<p>  a     = 2;\n  bbb >>= 2;\n<p>  false:\n  a >>= 2;\n  bbb = 2;\n<p>  a     = 2;\n  bbb >>= 2;"
        }
      },
      "x-intellij-html-description": "<p>Style of aligning consecutive declarations.\n<p>``Consecutive`` will align the declaration names of consecutive lines.\nThis will result in formattings like:\n<p>.. code-block:: c++\n<p>  int         aaaa = 12;\n  float       b = 23;\n  std::string ccc;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignConsecutiveDeclarations%20('>Documentation</a>\n"
    },
    "AlignConsecutiveMacros": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Enabled": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether aligning is enabled.\n<p>.. code-block:: c++\n<p>  #define SHORT_NAME       42\n  #define LONGER_NAME      0x007f\n  #define EVEN_LONGER_NAME (2)\n  #define foo(x)           (x * x)\n  #define bar(y, z)        (y + z)\n<p>  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int aaaa : 1;\n  int b    : 12;\n  int ccc  : 8;\n<p>  int         aaaa = 12;\n  float       b = 23;\n  std::string ccc;"
        },
        "AcrossEmptyLines": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across empty lines.\n<p>.. code-block:: c++\n<p>  true:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d            = 3;\n<p>  false:\n  int a            = 1;\n  int somelongname = 2;\n  double c         = 3;\n<p>  int d = 3;"
        },
        "AcrossComments": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Whether to align across comments.\n<p>.. code-block:: c++\n<p>  true:\n  int d    = 3;\n  /* A comment. */\n  double e = 4;\n<p>  false:\n  int d = 3;\n  /* A comment. */\n  double e = 4;"
        },
        "AlignCompound": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether compound assignments\nlike ``+=`` are aligned along with ``=``.\n<p>.. code-block:: c++\n<p>  true:\n  a   &= 2;\n  bbb  = 2;\n<p>  false:\n  a &= 2;\n  bbb = 2;"
        },
        "PadOperators": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Only for ``AlignConsecutiveAssignments``.  Whether short assignment\noperators are left-padded to the same length as long ones in order to\nput all assignment operators to the right of the left hand side.\n<p>.. code-block:: c++\n<p>  true:\n  a   >>= 2;\n  bbb   = 2;\n<p>  a     = 2;\n  bbb >>= 2;\n<p>  false:\n  a >>= 2;\n  bbb = 2;\n<p>  a     = 2;\n  bbb >>= 2;"
        }
      },
      "x-intellij-html-description": "<p>Style of aligning consecutive macro definitions.\n<p>``Consecutive`` will result in formattings like:\n<p>.. code-block:: c++\n<p>  #define SHORT_NAME       42\n  #define LONGER_NAME      0x007f\n  #define EVEN_LONGER_NAME (2)\n  #define foo(x)           (x * x)\n  #define bar(y, z)        (y + z)<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignConsecutiveMacros%20('>Documentation</a>\n"
    },
    "AlignEscapedNewlines": {
      "type": "string",
      "enum": [
        "DontAlign",
        "Left",
        "Right"
      ],
      "x-intellij-enum-metadata": {
        "DontAlign": {
          "description": "Don't align escaped newlines."
        },
        "Left": {
          "description": "Align escaped newlines as far left as possible."
        },
        "Right": {
          "description": "Align escaped newlines in the right-most column."
        }
      },
      "x-intellij-html-description": "<p>Options for aligning backslashes in escaped newlines.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignEscapedNewlines%20('>Documentation</a>\n"
    },
    "AlignOperands": {
      "type": "string",
      "enum": [
        "DontAlign",
        "Align",
        "AlignAfterOperator"
      ],
      "x-intellij-enum-metadata": {
        "DontAlign": {
          "description": "Do not align operands of binary and ternary expressions."
        },
        "Align": {
          "description": "Horizontally align operands of binary and ternary expressions."
        },
        "AlignAfterOperator": {
          "description": "Horizontally align operands of binary and ternary expressions."
        }
      },
      "x-intellij-html-description": "<p>If ``true``, horizontally align operands of binary and ternary\nexpressions.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignOperands%20('>Documentation</a>\n"
    },
    "AlignTrailingComments": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Kind": {
          "x-intellij-html-description": "<p>Specifies the way to align trailing comments.\n"
        },
        "OverEmptyLines": {
          "type": "number",
          "x-intellij-html-description": "<p>How many empty lines to apply alignment.\nWhen both ``MaxEmptyLinesToKeep`` and ``OverEmptyLines`` are set to 2,\nit formats like below.\n<p>.. code-block:: c++\n<p>  int a;      // all these\n<p>  int ab;     // comments are\n<p>\n  int abcdef; // aligned\n<p>When ``MaxEmptyLinesToKeep`` is set to 2 and ``OverEmptyLines`` is set\nto 1, it formats like below.\n<p>.. code-block:: c++\n<p>  int a;  // these are\n<p>  int ab; // aligned\n<p>\n  int abcdef; // but this isn't"
        }
      },
      "x-intellij-html-description": "<p>Control of trailing comments.\n<p>NOTE: As of clang-format 16 this option is not a bool but can be set\nto the options. Conventional bool options still can be parsed as before.\n<p>\n.. code-block:: yaml\n<p>  # Example of usage:\n  AlignTrailingComments:\n    Kind: Always\n    OverEmptyLines: 2<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlignTrailingComments%20('>Documentation</a>\n"
    },
    "AllowAllArgumentsOnNextLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If a function call or braced initializer list doesn't fit on a\nline, allow putting all arguments onto the next line, even if\n``BinPackArguments`` is ``false``.\n<p>.. code-block:: c++\n<p>  true:\n  callFunction(\n      a, b, c, d);\n<p>  false:\n  callFunction(a,\n               b,\n               c,\n               d);<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowAllArgumentsOnNextLine%20('>Documentation</a>\n"
    },
    "AllowAllConstructorInitializersOnNextLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>This option is **deprecated**. See ``NextLine`` of\n``PackConstructorInitializers``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowAllConstructorInitializersOnNextLine%20('>Documentation</a>\n"
    },
    "AllowAllParametersOfDeclarationOnNextLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If the function declaration doesn't fit on a line,\nallow putting all parameters of a function declaration onto\nthe next line even if ``BinPackParameters`` is ``false``.\n<p>.. code-block:: c++\n<p>  true:\n  void myFunction(\n      int a, int b, int c, int d, int e);\n<p>  false:\n  void myFunction(int a,\n                  int b,\n                  int c,\n                  int d,\n                  int e);<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowAllParametersOfDeclarationOnNextLine%20('>Documentation</a>\n"
    },
    "AllowShortBlocksOnASingleLine": {
      "type": "string",
      "enum": [
        "Never",
        "Empty",
        "Always"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Never merge blocks into a single line."
        },
        "Empty": {
          "description": "Only merge empty blocks."
        },
        "Always": {
          "description": "Always merge short blocks into a single line."
        }
      },
      "x-intellij-html-description": "<p>Dependent on the value, ``while (true) { continue; }`` can be put on a\nsingle line.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortBlocksOnASingleLine%20('>Documentation</a>\n"
    },
    "AllowShortCaseLabelsOnASingleLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, short case labels will be contracted to a single line.\n<p>.. code-block:: c++\n<p>  true:                                   false:\n  switch (a) {                    vs.     switch (a) {\n  case 1: x = 1; break;                   case 1:\n  case 2: return;                           x = 1;\n  }                                         break;\n                                          case 2:\n                                            return;\n                                          }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortCaseLabelsOnASingleLine%20('>Documentation</a>\n"
    },
    "AllowShortEnumsOnASingleLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Allow short enums on a single line.\n<p>.. code-block:: c++\n<p>  true:\n  enum { A, B } myEnum;\n<p>  false:\n  enum {\n    A,\n    B\n  } myEnum;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortEnumsOnASingleLine%20('>Documentation</a>\n"
    },
    "AllowShortFunctionsOnASingleLine": {
      "type": "string",
      "enum": [
        "None",
        "InlineOnly",
        "Empty",
        "Inline",
        "All"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Never merge functions into a single line."
        },
        "InlineOnly": {
          "description": "Only merge functions defined inside a class. Same as \"inline\","
        },
        "Empty": {
          "description": "Only merge empty functions."
        },
        "Inline": {
          "description": "Only merge functions defined inside a class. Implies \"empty\"."
        },
        "All": {
          "description": "Merge all functions fitting on a single line."
        }
      },
      "x-intellij-html-description": "<p>Dependent on the value, ``int f() { return 0; }`` can be put on a\nsingle line.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortFunctionsOnASingleLine%20('>Documentation</a>\n"
    },
    "AllowShortIfStatementsOnASingleLine": {
      "type": "string",
      "enum": [
        "Never",
        "WithoutElse",
        "OnlyFirstIf",
        "AllIfsAndElse"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Never put short ifs on the same line."
        },
        "WithoutElse": {
          "description": "Put short ifs on the same line only if there is no else statement."
        },
        "OnlyFirstIf": {
          "description": "Put short ifs, but not else ifs nor else statements, on the same line."
        },
        "AllIfsAndElse": {
          "description": "Always put short ifs, else ifs and else statements on the same"
        }
      },
      "x-intellij-html-description": "<p>Dependent on the value, ``if (a) return;`` can be put on a single line.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortIfStatementsOnASingleLine%20('>Documentation</a>\n"
    },
    "AllowShortLambdasOnASingleLine": {
      "type": "string",
      "enum": [
        "None",
        "Empty",
        "Inline",
        "All"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Never merge lambdas into a single line."
        },
        "Empty": {
          "description": "Only merge empty lambdas."
        },
        "Inline": {
          "description": "Merge lambda into a single line if the lambda is argument of a function."
        },
        "All": {
          "description": "Merge all lambdas fitting on a single line."
        }
      },
      "x-intellij-html-description": "<p>Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a\nsingle line.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortLambdasOnASingleLine%20('>Documentation</a>\n"
    },
    "AllowShortLoopsOnASingleLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, ``while (true) continue;`` can be put on a single\nline.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AllowShortLoopsOnASingleLine%20('>Documentation</a>\n"
    },
    "AlwaysBreakAfterDefinitionReturnType": {
      "type": "string",
      "enum": [
        "None",
        "All",
        "TopLevel"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Break after return type automatically."
        },
        "All": {
          "description": "Always break after the return type."
        },
        "TopLevel": {
          "description": "Always break after the return types of top-level functions."
        }
      },
      "x-intellij-html-description": "<p>The function definition return type breaking style to use.  This\noption is **deprecated** and is retained for backwards compatibility.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlwaysBreakAfterDefinitionReturnType%20('>Documentation</a>\n"
    },
    "AlwaysBreakAfterReturnType": {
      "type": "string",
      "enum": [
        "None",
        "All",
        "TopLevel",
        "AllDefinitions",
        "TopLevelDefinitions"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Break after return type automatically."
        },
        "All": {
          "description": "Always break after the return type."
        },
        "TopLevel": {
          "description": "Always break after the return types of top-level functions."
        },
        "AllDefinitions": {
          "description": "Always break after the return type of function definitions."
        },
        "TopLevelDefinitions": {
          "description": "Always break after the return type of top-level definitions."
        }
      },
      "x-intellij-html-description": "<p>The function declaration return type breaking style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlwaysBreakAfterReturnType%20('>Documentation</a>\n"
    },
    "AlwaysBreakBeforeMultilineStrings": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, always break before multiline string literals.\n<p>This flag is mean to make cases where there are multiple multiline strings\nin a file look more consistent. Thus, it will only take effect if wrapping\nthe string at that point leads to it being indented\n``ContinuationIndentWidth`` spaces from the start of the line.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   aaaa =                         vs.     aaaa = \"bbbb\"\n       \"bbbb\"                                    \"cccc\";\n       \"cccc\";<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlwaysBreakBeforeMultilineStrings%20('>Documentation</a>\n"
    },
    "AlwaysBreakTemplateDeclarations": {
      "type": "string",
      "enum": [
        "No",
        "MultiLine",
        "Yes"
      ],
      "x-intellij-enum-metadata": {
        "No": {
          "description": "Do not force break before declaration."
        },
        "MultiLine": {
          "description": "Force break after template declaration only when the following"
        },
        "Yes": {
          "description": "Always break after template declaration."
        }
      },
      "x-intellij-html-description": "<p>The template declaration breaking style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AlwaysBreakTemplateDeclarations%20('>Documentation</a>\n"
    },
    "AttributeMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of strings that should be interpreted as attributes/qualifiers\ninstead of identifiers. This can be useful for language extensions or\nstatic analyzer annotations.\n<p>For example:\n<p>.. code-block:: c++\n<p>  x = (char *__capability)&y;\n  int function(void) __ununsed;\n  void only_writes_to_buffer(char *__output buffer);\n<p>In the .clang-format configuration file, this can be configured like:\n<p>.. code-block:: yaml\n<p>  AttributeMacros: ['__capability', '__output', '__ununsed']<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=AttributeMacros%20('>Documentation</a>\n"
    },
    "BinPackArguments": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, a function call's arguments will either be all on the\nsame line or will have one line each.\n<p>.. code-block:: c++\n<p>  true:\n  void f() {\n    f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  }\n<p>  false:\n  void f() {\n    f(aaaaaaaaaaaaaaaaaaaa,\n      aaaaaaaaaaaaaaaaaaaa,\n      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BinPackArguments%20('>Documentation</a>\n"
    },
    "BinPackParameters": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, a function declaration's or function definition's\nparameters will either all be on the same line or will have one line each.\n<p>.. code-block:: c++\n<p>  true:\n  void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n         int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n<p>  false:\n  void f(int aaaaaaaaaaaaaaaaaaaa,\n         int aaaaaaaaaaaaaaaaaaaa,\n         int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BinPackParameters%20('>Documentation</a>\n"
    },
    "BitFieldColonSpacing": {
      "type": "string",
      "enum": [
        "Both",
        "None",
        "Before",
        "After"
      ],
      "x-intellij-enum-metadata": {
        "Both": {
          "description": "Add one space on each side of the ``:``"
        },
        "None": {
          "description": "Add no space around the ``:`` (except when needed for"
        },
        "Before": {
          "description": "Add space before the ``:`` only"
        },
        "After": {
          "description": "Add space after the ``:`` only (space may be added before if"
        }
      },
      "x-intellij-html-description": "<p>The BitFieldColonSpacingStyle to use for bitfields.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BitFieldColonSpacing%20('>Documentation</a>\n"
    },
    "BraceWrapping": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "AfterCaseLabel": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap case labels.\n<p>.. code-block:: c++\n<p>  false:                                true:\n  switch (foo) {                vs.     switch (foo) {\n    case 1: {                             case 1:\n      bar();                              {\n      break;                                bar();\n    }                                       break;\n    default: {                            }\n      plop();                             default:\n    }                                     {\n  }                                         plop();\n                                          }\n                                        }"
        },
        "AfterClass": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap class definitions.\n<p>.. code-block:: c++\n<p>  true:\n  class foo\n  {};\n<p>  false:\n  class foo {};"
        },
        "AfterControlStatement": {
          "x-intellij-html-description": "<p>Wrap control statements (``if``/``for``/``while``/``switch``/..).\n"
        },
        "AfterEnum": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap enum definitions.\n<p>.. code-block:: c++\n<p>  true:\n  enum X : int\n  {\n    B\n  };\n<p>  false:\n  enum X : int { B };"
        },
        "AfterFunction": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap function definitions.\n<p>.. code-block:: c++\n<p>  true:\n  void foo()\n  {\n    bar();\n    bar2();\n  }\n<p>  false:\n  void foo() {\n    bar();\n    bar2();\n  }"
        },
        "AfterNamespace": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap namespace definitions.\n<p>.. code-block:: c++\n<p>  true:\n  namespace\n  {\n  int foo();\n  int bar();\n  }\n<p>  false:\n  namespace {\n  int foo();\n  int bar();\n  }"
        },
        "AfterObjCDeclaration": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap ObjC definitions (interfaces, implementations...).\n@autoreleasepool and @synchronized blocks are wrapped\naccording to `AfterControlStatement` flag."
        },
        "AfterStruct": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap struct definitions.\n<p>.. code-block:: c++\n<p>  true:\n  struct foo\n  {\n    int x;\n  };\n<p>  false:\n  struct foo {\n    int x;\n  };"
        },
        "AfterUnion": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap union definitions.\n<p>.. code-block:: c++\n<p>  true:\n  union foo\n  {\n    int x;\n  }\n<p>  false:\n  union foo {\n    int x;\n  }"
        },
        "AfterExternBlock": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap extern blocks.\n<p>.. code-block:: c++\n<p>  true:\n  extern \"C\"\n  {\n    int foo();\n  }\n<p>  false:\n  extern \"C\" {\n  int foo();\n  }"
        },
        "BeforeCatch": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap before ``catch``.\n<p>.. code-block:: c++\n<p>  true:\n  try {\n    foo();\n  }\n  catch () {\n  }\n<p>  false:\n  try {\n    foo();\n  } catch () {\n  }"
        },
        "BeforeElse": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap before ``else``.\n<p>.. code-block:: c++\n<p>  true:\n  if (foo()) {\n  }\n  else {\n  }\n<p>  false:\n  if (foo()) {\n  } else {\n  }"
        },
        "BeforeLambdaBody": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap lambda block.\n<p>.. code-block:: c++\n<p>  true:\n  connect(\n    []()\n    {\n      foo();\n      bar();\n    });\n<p>  false:\n  connect([]() {\n    foo();\n    bar();\n  });"
        },
        "BeforeWhile": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Wrap before ``while``.\n<p>.. code-block:: c++\n<p>  true:\n  do {\n    foo();\n  }\n  while (1);\n<p>  false:\n  do {\n    foo();\n  } while (1);"
        },
        "IndentBraces": {
          "type": "boolean",
          "x-intellij-html-description": "<p>Indent the wrapped braces themselves."
        },
        "SplitEmptyFunction": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``false``, empty function body can be put on a single line.\nThis option is used only if the opening brace of the function has\nalready been wrapped, i.e. the `AfterFunction` brace wrapping mode is\nset, and the function could/should not be put on a single line (as per\n`AllowShortFunctionsOnASingleLine` and constructor formatting options).\n<p>.. code-block:: c++\n<p>  false:          true:\n  int f()   vs.   int f()\n  {}              {\n                  }"
        },
        "SplitEmptyRecord": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``false``, empty record (e.g. class, struct or union) body\ncan be put on a single line. This option is used only if the opening\nbrace of the record has already been wrapped, i.e. the `AfterClass`\n(for classes) brace wrapping mode is set.\n<p>.. code-block:: c++\n<p>  false:           true:\n  class Foo   vs.  class Foo\n  {}               {\n                   }"
        },
        "SplitEmptyNamespace": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``false``, empty namespace body can be put on a single line.\nThis option is used only if the opening brace of the namespace has\nalready been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\nset.\n<p>.. code-block:: c++\n<p>  false:               true:\n  namespace Foo   vs.  namespace Foo\n  {}                   {\n                       }"
        }
      },
      "x-intellij-html-description": "<p>Control of individual brace wrapping cases.\n<p>If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how\neach individual brace case should be handled. Otherwise, this is ignored.\n<p>.. code-block:: yaml\n<p>  # Example of usage:\n  BreakBeforeBraces: Custom\n  BraceWrapping:\n    AfterEnum: true\n    AfterStruct: false\n    SplitEmptyFunction: false<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BraceWrapping%20('>Documentation</a>\n"
    },
    "BreakAfterJavaFieldAnnotations": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Break after each annotation on a field in Java files.\n<p>.. code-block:: java\n<p>   true:                                  false:\n   @Partial                       vs.     @Partial @Mock DataLoad loader;\n   @Mock\n   DataLoad loader;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakAfterJavaFieldAnnotations%20('>Documentation</a>\n"
    },
    "BreakArrays": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, clang-format will always break after a Json array `[`\notherwise it will scan until the closing `]` to determine if it should add\nnewlines between elements (prettier compatible).\n<p>NOTE: This is currently only for formatting JSON.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   [                          vs.      [1, 2, 3, 4]\n     1,\n     2,\n     3,\n     4\n   ]<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakArrays%20('>Documentation</a>\n"
    },
    "BreakBeforeBinaryOperators": {
      "type": "string",
      "enum": [
        "None",
        "NonAssignment",
        "All"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Break after operators."
        },
        "NonAssignment": {
          "description": "Break before operators that aren't assignments."
        },
        "All": {
          "description": "Break before operators."
        }
      },
      "x-intellij-html-description": "<p>The way to wrap binary operators.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakBeforeBinaryOperators%20('>Documentation</a>\n"
    },
    "BreakBeforeBraces": {
      "type": "string",
      "enum": [
        "Attach",
        "Linux",
        "Mozilla",
        "Stroustrup",
        "Allman",
        "Whitesmiths",
        "GNU",
        "WebKit",
        "Custom"
      ],
      "x-intellij-enum-metadata": {
        "Attach": {
          "description": "Always attach braces to surrounding context."
        },
        "Linux": {
          "description": "Like ``Attach``, but break before braces on function, namespace and"
        },
        "Mozilla": {
          "description": "Like ``Attach``, but break before braces on enum, function, and record"
        },
        "Stroustrup": {
          "description": "Like ``Attach``, but break before function definitions, ``catch``, and"
        },
        "Allman": {
          "description": "Always break before braces."
        },
        "Whitesmiths": {
          "description": "Like ``Allman`` but always indent braces and line up code with braces."
        },
        "GNU": {
          "description": "Always break before braces and add an extra level of indentation to"
        },
        "WebKit": {
          "description": "Like ``Attach``, but break before functions."
        },
        "Custom": {
          "description": "Configure each individual brace in `BraceWrapping`."
        }
      },
      "x-intellij-html-description": "<p>The brace breaking style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakBeforeBraces%20('>Documentation</a>\n"
    },
    "BreakBeforeConceptDeclarations": {
      "type": "string",
      "enum": [
        "Never",
        "Allowed",
        "Always"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Keep the template declaration line together with ``concept``."
        },
        "Allowed": {
          "description": "Breaking between template declaration and ``concept`` is allowed. The"
        },
        "Always": {
          "description": "Always break before ``concept``, putting it in the line after the"
        }
      },
      "x-intellij-html-description": "<p>The concept declaration style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakBeforeConceptDeclarations%20('>Documentation</a>\n"
    },
    "BreakBeforeInlineASMColon": {
      "type": "string",
      "enum": [
        "Never",
        "OnlyMultiline",
        "Always"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "No break before inline ASM colon."
        },
        "OnlyMultiline": {
          "description": "Break before inline ASM colon if the line length is longer than column"
        },
        "Always": {
          "description": "Always break before inline ASM colon."
        }
      },
      "x-intellij-html-description": "<p>The inline ASM colon style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakBeforeInlineASMColon%20('>Documentation</a>\n"
    },
    "BreakBeforeTernaryOperators": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, ternary operators will be placed after line breaks.\n<p>.. code-block:: c++\n<p>   true:\n   veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n       ? firstValue\n       : SecondValueVeryVeryVeryVeryLong;\n<p>   false:\n   veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n       firstValue :\n       SecondValueVeryVeryVeryVeryLong;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakBeforeTernaryOperators%20('>Documentation</a>\n"
    },
    "BreakConstructorInitializers": {
      "type": "string",
      "enum": [
        "BeforeColon",
        "BeforeComma",
        "AfterColon"
      ],
      "x-intellij-enum-metadata": {
        "BeforeColon": {
          "description": "Break constructor initializers before the colon and after the commas."
        },
        "BeforeComma": {
          "description": "Break constructor initializers before the colon and commas, and align"
        },
        "AfterColon": {
          "description": "Break constructor initializers after the colon and commas."
        }
      },
      "x-intellij-html-description": "<p>The break constructor initializers style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakConstructorInitializers%20('>Documentation</a>\n"
    },
    "BreakInheritanceList": {
      "type": "string",
      "enum": [
        "BeforeColon",
        "BeforeComma",
        "AfterColon",
        "AfterComma"
      ],
      "x-intellij-enum-metadata": {
        "BeforeColon": {
          "description": "Break inheritance list before the colon and after the commas."
        },
        "BeforeComma": {
          "description": "Break inheritance list before the colon and commas, and align"
        },
        "AfterColon": {
          "description": "Break inheritance list after the colon and commas."
        },
        "AfterComma": {
          "description": "Break inheritance list only after the commas."
        }
      },
      "x-intellij-html-description": "<p>The inheritance list style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakInheritanceList%20('>Documentation</a>\n"
    },
    "BreakStringLiterals": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Allow breaking string literals when formatting.\n<p>.. code-block:: c++\n<p>   true:\n   const char* x = \"veryVeryVeryVeryVeryVe\"\n                   \"ryVeryVeryVeryVeryVery\"\n                   \"VeryLongString\";\n<p>   false:\n   const char* x =\n     \"veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString\";<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=BreakStringLiterals%20('>Documentation</a>\n"
    },
    "ColumnLimit": {
      "type": "number",
      "x-intellij-html-description": "<p>The column limit.\n<p>A column limit of ``0`` means that there is no column limit. In this case,\nclang-format will respect the input's line breaking decisions within\nstatements unless they contradict other rules.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ColumnLimit%20('>Documentation</a>\n"
    },
    "CommentPragmas": {
      "type": "string",
      "x-intellij-html-description": "<p>A regular expression that describes comments with special meaning,\nwhich should not be split into lines or otherwise changed.\n<p>.. code-block:: c++\n<p>   // CommentPragmas: '^ FOOBAR pragma:'\n   // Will leave the following line unaffected\n   #include <vector> // FOOBAR pragma: keep<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=CommentPragmas%20('>Documentation</a>\n"
    },
    "CompactNamespaces": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, consecutive namespace declarations will be on the same\nline. If ``false``, each namespace is declared on a new line.\n<p>.. code-block:: c++\n<p>  true:\n  namespace Foo { namespace Bar {\n  }}\n<p>  false:\n  namespace Foo {\n  namespace Bar {\n  }\n  }\n<p>If it does not fit on a single line, the overflowing namespaces get\nwrapped:\n<p>.. code-block:: c++\n<p>  namespace Foo { namespace Bar {\n  namespace Extra {\n  }}}<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=CompactNamespaces%20('>Documentation</a>\n"
    },
    "ConstructorInitializerAllOnOneLineOrOnePerLine": {
      "type": "boolean",
      "x-intellij-html-description": "<p>This option is **deprecated**. See ``CurrentLine`` of\n``PackConstructorInitializers``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ConstructorInitializerAllOnOneLineOrOnePerLine%20('>Documentation</a>\n"
    },
    "ConstructorInitializerIndentWidth": {
      "type": "number",
      "x-intellij-html-description": "<p>The number of characters to use for indentation of constructor\ninitializer lists as well as inheritance lists.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ConstructorInitializerIndentWidth%20('>Documentation</a>\n"
    },
    "ContinuationIndentWidth": {
      "type": "number",
      "x-intellij-html-description": "<p>Indent width for line continuations.\n<p>.. code-block:: c++\n<p>   ContinuationIndentWidth: 2\n<p>   int i =         //  VeryVeryVeryVeryVeryLongComment\n     longFunction( // Again a long comment\n       arg);<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ContinuationIndentWidth%20('>Documentation</a>\n"
    },
    "Cpp11BracedListStyle": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, format braced lists as best suited for C++11 braced\nlists.\n<p>Important differences:\n- No spaces inside the braced list.\n- No line break before the closing brace.\n- Indentation with the continuation indent, not with the block indent.\n<p>Fundamentally, C++11 braced lists are formatted exactly like function\ncalls would be formatted in their place. If the braced list follows a name\n(e.g. a type or variable name), clang-format formats as if the ``{}`` were\nthe parentheses of a function call with that name. If there is no name,\na zero-length name is assumed.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   vector<int> x{1, 2, 3, 4};     vs.     vector<int> x{ 1, 2, 3, 4 };\n   vector<T> x{{}, {}, {}, {}};           vector<T> x{ {}, {}, {}, {} };\n   f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n   new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=Cpp11BracedListStyle%20('>Documentation</a>\n"
    },
    "DeriveLineEnding": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Analyze the formatted file for the most used line ending (``\\r\\n``\nor ``\\n``). ``UseCRLF`` is only used as a fallback if none can be derived.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=DeriveLineEnding%20('>Documentation</a>\n"
    },
    "DerivePointerAlignment": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, analyze the formatted file for the most common\nalignment of ``&`` and ``*``.\nPointer and reference alignment styles are going to be updated according\nto the preferences found in the file.\n``PointerAlignment`` is then used only as fallback.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=DerivePointerAlignment%20('>Documentation</a>\n"
    },
    "DisableFormat": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Disables formatting completely.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=DisableFormat%20('>Documentation</a>\n"
    },
    "EmptyLineAfterAccessModifier": {
      "type": "string",
      "enum": [
        "Never",
        "Leave",
        "Always"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Remove all empty lines after access modifiers."
        },
        "Leave": {
          "description": "Keep existing empty lines after access modifiers."
        },
        "Always": {
          "description": "Always add empty line after access modifiers if there are none."
        }
      },
      "x-intellij-html-description": "<p>Defines when to put an empty line after access modifiers.\n``EmptyLineBeforeAccessModifier`` configuration handles the number of\nempty lines between two access modifiers.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=EmptyLineAfterAccessModifier%20('>Documentation</a>\n"
    },
    "EmptyLineBeforeAccessModifier": {
      "type": "string",
      "enum": [
        "Never",
        "Leave",
        "LogicalBlock",
        "Always"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Remove all empty lines before access modifiers."
        },
        "Leave": {
          "description": "Keep existing empty lines before access modifiers."
        },
        "LogicalBlock": {
          "description": "Add empty line only when access modifier starts a new logical block."
        },
        "Always": {
          "description": "Always add empty line before access modifiers unless access modifier"
        }
      },
      "x-intellij-html-description": "<p>Defines in which cases to put empty line before access modifiers.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=EmptyLineBeforeAccessModifier%20('>Documentation</a>\n"
    },
    "ExperimentalAutoDetectBinPacking": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, clang-format detects whether function calls and\ndefinitions are formatted with one parameter per line.\n<p>Each call can be bin-packed, one-per-line or inconclusive. If it is\ninconclusive, e.g. completely on one line, but a decision needs to be\nmade, clang-format analyzes whether there are other bin-packed cases in\nthe input file and act accordingly.\n<p>NOTE: This is an experimental flag, that might go away or be renamed. Do\nnot use this in config files, etc. Use at your own risk.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ExperimentalAutoDetectBinPacking%20('>Documentation</a>\n"
    },
    "FixNamespaceComments": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, clang-format adds missing namespace end comments for\nnamespaces and fixes invalid existing ones. This doesn't affect short\nnamespaces, which are controlled by ``ShortNamespaceLines``.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   namespace longNamespace {      vs.     namespace longNamespace {\n   void foo();                            void foo();\n   void bar();                            void bar();\n   } // namespace a                       }\n   namespace shortNamespace {             namespace shortNamespace {\n   void baz();                            void baz();\n   }                                      }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=FixNamespaceComments%20('>Documentation</a>\n"
    },
    "ForEachMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of macros that should be interpreted as foreach loops\ninstead of as function calls.\n<p>These are expected to be macros of the form:\n<p>.. code-block:: c++\n<p>  FOREACH(<variable-declaration>, ...)\n    <loop-body>\n<p>In the .clang-format configuration file, this can be configured like:\n<p>.. code-block:: yaml\n<p>  ForEachMacros: ['RANGES_FOR', 'FOREACH']\n<p>For example: BOOST_FOREACH.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ForEachMacros%20('>Documentation</a>\n"
    },
    "IfMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of macros that should be interpreted as conditionals\ninstead of as function calls.\n<p>These are expected to be macros of the form:\n<p>.. code-block:: c++\n<p>  IF(...)\n    <conditional-body>\n  else IF(...)\n    <conditional-body>\n<p>In the .clang-format configuration file, this can be configured like:\n<p>.. code-block:: yaml\n<p>  IfMacros: ['IF']\n<p>For example: `KJ_IF_MAYBE\n<https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IfMacros%20('>Documentation</a>\n"
    },
    "IncludeBlocks": {
      "type": "string",
      "enum": [
        "Preserve",
        "Merge",
        "Regroup"
      ],
      "x-intellij-enum-metadata": {
        "Preserve": {
          "description": "Sort each ``#include`` block separately."
        },
        "Merge": {
          "description": "Merge multiple ``#include`` blocks together and sort as one."
        },
        "Regroup": {
          "description": "Merge multiple ``#include`` blocks together and sort as one."
        }
      },
      "x-intellij-html-description": "<p>Dependent on the value, multiple ``#include`` blocks can be sorted\nas one and divided based on category.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IncludeBlocks%20('>Documentation</a>\n"
    },
    "IncludeCategories": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "Regex": {
            "type": "string"
          },
          "Priority": {
            "type": "integer"
          },
          "SortPriority": {
            "type": "integer"
          },
          "CaseSensitive": {
            "type": "boolean"
          }
        }
      },
      "x-intellij-html-description": "<p>Regular expressions denoting the different ``#include`` categories\nused for ordering ``#includes``.\n<p>`POSIX extended\n<https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_\nregular expressions are supported.\n<p>These regular expressions are matched against the filename of an include\n(including the <> or \"\") in order. The value belonging to the first\nmatching regular expression is assigned and ``#includes`` are sorted first\naccording to increasing category number and then alphabetically within\neach category.\n<p>If none of the regular expressions match, INT_MAX is assigned as\ncategory. The main header for a source file automatically gets category 0.\nso that it is generally kept at the beginning of the ``#includes``\n(https://llvm.org/docs/CodingStandards.html#include-style). However, you\ncan also assign negative priorities if you have certain headers that\nalways need to be first.\n<p>There is a third and optional field ``SortPriority`` which can used while\n``IncludeBlocks = IBS_Regroup`` to define the priority in which\n``#includes`` should be ordered. The value of ``Priority`` defines the\norder of ``#include blocks`` and also allows the grouping of ``#includes``\nof different priority. ``SortPriority`` is set to the value of\n``Priority`` as default if it is not assigned.\n<p>Each regular expression can be marked as case sensitive with the field\n``CaseSensitive``, per default it is not.\n<p>To configure this in the .clang-format file, use:\n<p>.. code-block:: yaml\n<p>  IncludeCategories:\n    - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n      Priority:        2\n      SortPriority:    2\n      CaseSensitive:   true\n    - Regex:           '^((<|\")(gtest|gmock|isl|json)/)'\n      Priority:        3\n    - Regex:           '<[[:alnum:].]+>'\n      Priority:        4\n    - Regex:           '.*'\n      Priority:        1\n      SortPriority:    0<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IncludeCategories%20('>Documentation</a>\n"
    },
    "IncludeIsMainRegex": {
      "type": "string",
      "x-intellij-html-description": "<p>Specify a regular expression of suffixes that are allowed in the\nfile-to-main-include mapping.\n<p>When guessing whether a #include is the \"main\" include (to assign\ncategory 0, see above), use this regex of allowed suffixes to the header\nstem. A partial match is done, so that:\n- \"\" means \"arbitrary suffix\"\n- \"$\" means \"no suffix\"\n<p>For example, if configured to \"(_test)?$\", then a header a.h would be seen\nas the \"main\" include in both a.cc and a_test.cc.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IncludeIsMainRegex%20('>Documentation</a>\n"
    },
    "IncludeIsMainSourceRegex": {
      "type": "string",
      "x-intellij-html-description": "<p>Specify a regular expression for files being formatted\nthat are allowed to be considered \"main\" in the\nfile-to-main-include mapping.\n<p>By default, clang-format considers files as \"main\" only when they end\nwith: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``\nextensions.\nFor these files a guessing of \"main\" include takes place\n(to assign category 0, see above). This config option allows for\nadditional suffixes and extensions for files to be considered as \"main\".\n<p>For example, if this option is configured to ``(Impl\\.hpp)$``,\nthen a file ``ClassImpl.hpp`` is considered \"main\" (in addition to\n``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and \"main\ninclude file\" logic will be executed (with *IncludeIsMainRegex* setting\nalso being respected in later phase). Without this option set,\n``ClassImpl.hpp`` would not have the main include file put on top\nbefore any other include.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IncludeIsMainSourceRegex%20('>Documentation</a>\n"
    },
    "IndentAccessModifiers": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Specify whether access modifiers should have their own indentation level.\n<p>When ``false``, access modifiers are indented (or outdented) relative to\nthe record members, respecting the ``AccessModifierOffset``. Record\nmembers are indented one level below the record.\nWhen ``true``, access modifiers get their own indentation level. As a\nconsequence, record members are always indented 2 levels below the record,\nregardless of the access modifier presence. Value of the\n``AccessModifierOffset`` is ignored.\n<p>.. code-block:: c++\n<p>   false:                                 true:\n   class C {                      vs.     class C {\n     class D {                                class D {\n       void bar();                                void bar();\n     protected:                                 protected:\n       D();                                       D();\n     };                                       };\n   public:                                  public:\n     C();                                     C();\n   };                                     };\n   void foo() {                           void foo() {\n     return 1;                              return 1;\n   }                                      }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentAccessModifiers%20('>Documentation</a>\n"
    },
    "IndentCaseBlocks": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Indent case label blocks one level from the case label.\n<p>When ``false``, the block following the case label uses the same\nindentation level as for the case label, treating the case label the same\nas an if-statement.\nWhen ``true``, the block gets indented as a scope block.\n<p>.. code-block:: c++\n<p>   false:                                 true:\n   switch (fool) {                vs.     switch (fool) {\n   case 1: {                              case 1:\n     bar();                                 {\n   } break;                                   bar();\n   default: {                               }\n     plop();                                break;\n   }                                      default:\n   }                                        {\n                                              plop();\n                                            }\n                                          }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentCaseBlocks%20('>Documentation</a>\n"
    },
    "IndentCaseLabels": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Indent case labels one level from the switch statement.\n<p>When ``false``, use the same indentation level as for the switch\nstatement. Switch statement body is always indented one level more than\ncase labels (except the first block following the case label, which\nitself indents the code - unless IndentCaseBlocks is enabled).\n<p>.. code-block:: c++\n<p>   false:                                 true:\n   switch (fool) {                vs.     switch (fool) {\n   case 1:                                  case 1:\n     bar();                                   bar();\n     break;                                   break;\n   default:                                 default:\n     plop();                                  plop();\n   }                                      }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentCaseLabels%20('>Documentation</a>\n"
    },
    "IndentExternBlock": {
      "type": "string",
      "enum": [
        "AfterExternBlock",
        "NoIndent",
        "Indent"
      ],
      "x-intellij-enum-metadata": {
        "AfterExternBlock": {
          "description": "Backwards compatible with AfterExternBlock's indenting."
        },
        "NoIndent": {
          "description": "Does not indent extern blocks."
        },
        "Indent": {
          "description": "Indents extern blocks."
        }
      },
      "x-intellij-html-description": "<p>IndentExternBlockStyle is the type of indenting of extern blocks.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentExternBlock%20('>Documentation</a>\n"
    },
    "IndentGotoLabels": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Indent goto labels.\n<p>When ``false``, goto labels are flushed left.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   int f() {                      vs.     int f() {\n     if (foo()) {                           if (foo()) {\n     label1:                              label1:\n       bar();                                 bar();\n     }                                      }\n   label2:                                label2:\n     return 1;                              return 1;\n   }                                      }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentGotoLabels%20('>Documentation</a>\n"
    },
    "IndentPPDirectives": {
      "type": "string",
      "enum": [
        "None",
        "AfterHash",
        "BeforeHash"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Does not indent any directives."
        },
        "AfterHash": {
          "description": "Indents directives after the hash."
        },
        "BeforeHash": {
          "description": "Indents directives before the hash."
        }
      },
      "x-intellij-html-description": "<p>The preprocessor directive indenting style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentPPDirectives%20('>Documentation</a>\n"
    },
    "IndentRequiresClause": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Indent the requires clause in a template. This only applies when\n``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``.\n<p>In clang-format 12, 13 and 14 it was named ``IndentRequires``.\n<p>.. code-block:: c++\n<p>   true:\n   template <typename It>\n     requires Iterator<It>\n   void sort(It begin, It end) {\n     //....\n   }\n<p>   false:\n   template <typename It>\n   requires Iterator<It>\n   void sort(It begin, It end) {\n     //....\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentRequiresClause%20('>Documentation</a>\n"
    },
    "IndentWidth": {
      "type": "number",
      "x-intellij-html-description": "<p>The number of columns to use for indentation.\n<p>.. code-block:: c++\n<p>   IndentWidth: 3\n<p>   void f() {\n      someFunction();\n      if (true, false) {\n         f();\n      }\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentWidth%20('>Documentation</a>\n"
    },
    "IndentWrappedFunctionNames": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Indent if a function definition or declaration is wrapped after the\ntype.\n<p>.. code-block:: c++\n<p>   true:\n   LoooooooooooooooooooooooooooooooooooooooongReturnType\n       LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n<p>   false:\n   LoooooooooooooooooooooooooooooooooooooooongReturnType\n   LoooooooooooooooooooooooooooooooongFunctionDeclaration();<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IndentWrappedFunctionNames%20('>Documentation</a>\n"
    },
    "InsertBraces": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Insert braces after control statements (``if``, ``else``, ``for``, ``do``,\nand ``while``) in C++ unless the control statements are inside macro\ndefinitions or the braces would enclose preprocessor directives.\n<p>.. warning:: \n<p> Setting this option to `true` could lead to incorrect code formatting due\n to clang-format's lack of complete semantic information. As such, extra\n care should be taken to review code changes made by this option.\n<p>.. code-block:: c++\n<p>  false:                                    true:\n<p>  if (isa<FunctionDecl>(D))        vs.      if (isa<FunctionDecl>(D)) {\n    handleFunctionDecl(D);                    handleFunctionDecl(D);\n  else if (isa<VarDecl>(D))                 } else if (isa<VarDecl>(D)) {\n    handleVarDecl(D);                         handleVarDecl(D);\n  else                                      } else {\n    return;                                   return;\n                                            }\n<p>  while (i--)                      vs.      while (i--) {\n    for (auto *A : D.attrs())                 for (auto *A : D.attrs()) {\n      handleAttr(A);                            handleAttr(A);\n                                              }\n                                            }\n<p>  do                               vs.      do {\n    --i;                                      --i;\n  while (i);                                } while (i);<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=InsertBraces%20('>Documentation</a>\n"
    },
    "InsertTrailingCommas": {
      "type": "string",
      "enum": [
        "None",
        "Wrapped"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Do not insert trailing commas."
        },
        "Wrapped": {
          "description": "Insert trailing commas in container literals that were wrapped over"
        }
      },
      "x-intellij-html-description": "<p>If set to ``TCS_Wrapped`` will insert trailing commas in container\nliterals (arrays and objects) that wrap across multiple lines.\nIt is currently only available for JavaScript\nand disabled by default ``TCS_None``.\n``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``\nas inserting the comma disables bin-packing.\n<p>.. code-block:: c++\n<p>  TSC_Wrapped:\n  const someArray = [\n  aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  //                        ^ inserted\n  ]<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=InsertTrailingCommas%20('>Documentation</a>\n"
    },
    "IntegerLiteralSeparator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Binary": {
          "type": "???(int8_t)",
          "x-intellij-html-description": "<p>.. code-block:: c++\n<p>   -1: 0b100111101101\n    0: 0b10011'11'0110'1\n    3: 0b100'111'101'101\n    4: 0b1001'1110'1101"
        },
        "Decimal": {
          "type": "???(int8_t)",
          "x-intellij-html-description": "<p>.. code-block:: c++\n<p>   -1: 18446744073709550592ull\n    0: 184467'440737'0'95505'92ull\n    3: 18'446'744'073'709'550'592ull"
        },
        "Hex": {
          "type": "???(int8_t)",
          "x-intellij-html-description": "<p>.. code-block:: c++\n<p>   -1: 0xDEADBEEFDEADBEEFuz\n    0: 0xDEAD'BEEF'DE'AD'BEE'Fuz\n    2: 0xDE'AD'BE'EF'DE'AD'BE'EFuz"
        }
      },
      "x-intellij-html-description": "<p>Format integer literal separators (``'`` for C++ and ``_`` for C#, Java,\nand JavaScript).<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=IntegerLiteralSeparator%20('>Documentation</a>\n"
    },
    "JavaImportGroups": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of prefixes ordered by the desired groups for Java imports.\n<p>One group's prefix can be a subset of another - the longest prefix is\nalways matched. Within a group, the imports are ordered lexicographically.\nStatic imports are grouped separately and follow the same group rules.\nBy default, static imports are placed before non-static imports,\nbut this behavior is changed by another option,\n``SortJavaStaticImport``.\n<p>In the .clang-format configuration file, this can be configured like\nin the following yaml example. This will result in imports being\nformatted as in the Java example below.\n<p>.. code-block:: yaml\n<p>  JavaImportGroups: ['com.example', 'com', 'org']\n<p>\n.. code-block:: java\n<p>   import static com.example.function1;\n<p>   import static com.test.function2;\n<p>   import static org.example.function3;\n<p>   import com.example.ClassA;\n   import com.example.Test;\n   import com.example.a.ClassB;\n<p>   import com.test.ClassC;\n<p>   import org.example.ClassD;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=JavaImportGroups%20('>Documentation</a>\n"
    },
    "JavaScriptQuotes": {
      "type": "string",
      "enum": [
        "Leave",
        "Single",
        "Double"
      ],
      "x-intellij-enum-metadata": {
        "Leave": {
          "description": "Leave string quotes as they are."
        },
        "Single": {
          "description": "Always use single quotes."
        },
        "Double": {
          "description": "Always use double quotes."
        }
      },
      "x-intellij-html-description": "<p>The JavaScriptQuoteStyle to use for JavaScript strings.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=JavaScriptQuotes%20('>Documentation</a>\n"
    },
    "JavaScriptWrapImports": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Whether to wrap JavaScript import/export statements.\n<p>.. code-block:: js\n<p>   true:\n   import {\n       VeryLongImportsAreAnnoying,\n       VeryLongImportsAreAnnoying,\n       VeryLongImportsAreAnnoying,\n   } from 'some/module.js'\n<p>   false:\n   import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from \"some/module.js\"<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=JavaScriptWrapImports%20('>Documentation</a>\n"
    },
    "KeepEmptyLinesAtTheStartOfBlocks": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If true, the empty line at the start of blocks is kept.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   if (foo) {                     vs.     if (foo) {\n                                            bar();\n     bar();                               }\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=KeepEmptyLinesAtTheStartOfBlocks%20('>Documentation</a>\n"
    },
    "LambdaBodyIndentation": {
      "type": "string",
      "enum": [
        "Signature",
        "OuterScope"
      ],
      "x-intellij-enum-metadata": {
        "Signature": {
          "description": "Align lambda body relative to the lambda signature. This is the default."
        },
        "OuterScope": {
          "description": "Align lambda body relative to the indentation level of the outer scope"
        }
      },
      "x-intellij-html-description": "<p>The indentation style of lambda bodies. ``Signature`` (the default)\ncauses the lambda body to be indented one additional level relative to\nthe indentation level of the signature. ``OuterScope`` forces the lambda\nbody to be indented one additional level relative to the parent scope\ncontaining the lambda signature. For callback-heavy code, it may improve\nreadability to have the signature indented two levels and to use\n``OuterScope``. The KJ style guide requires ``OuterScope``.\n`KJ style guide\n<https://github.com/capnproto/capnproto/blob/master/style-guide.md>`_<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=LambdaBodyIndentation%20('>Documentation</a>\n"
    },
    "Language": {
      "type": "string",
      "enum": [
        "None",
        "Cpp",
        "CSharp",
        "Java",
        "JavaScript",
        "Json",
        "ObjC",
        "Proto",
        "TableGen",
        "TextProto",
        "Verilog"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Do not use."
        },
        "Cpp": {
          "description": "Should be used for C, C++."
        },
        "CSharp": {
          "description": "Should be used for C#."
        },
        "Java": {
          "description": "Should be used for Java."
        },
        "JavaScript": {
          "description": "Should be used for JavaScript."
        },
        "Json": {
          "description": "Should be used for JSON."
        },
        "ObjC": {
          "description": "Should be used for Objective-C, Objective-C++."
        },
        "Proto": {
          "description": "Should be used for Protocol Buffers"
        },
        "TableGen": {
          "description": "Should be used for TableGen code."
        },
        "TextProto": {
          "description": "Should be used for Protocol Buffer messages in text format"
        },
        "Verilog": {
          "description": "Should be used for Verilog and SystemVerilog."
        }
      },
      "x-intellij-html-description": "<p>Language, this format style is targeted at.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=Language%20('>Documentation</a>\n"
    },
    "MacroBlockBegin": {
      "type": "string",
      "x-intellij-html-description": "<p>A regular expression matching macros that start a block.\n<p>.. code-block:: c++\n<p>   # With:\n   MacroBlockBegin: \"^NS_MAP_BEGIN|\\\n   NS_TABLE_HEAD$\"\n   MacroBlockEnd: \"^\\\n   NS_MAP_END|\\\n   NS_TABLE_.*_END$\"\n<p>   NS_MAP_BEGIN\n     foo();\n   NS_MAP_END\n<p>   NS_TABLE_HEAD\n     bar();\n   NS_TABLE_FOO_END\n<p>   # Without:\n   NS_MAP_BEGIN\n   foo();\n   NS_MAP_END\n<p>   NS_TABLE_HEAD\n   bar();\n   NS_TABLE_FOO_END<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=MacroBlockBegin%20('>Documentation</a>\n"
    },
    "MacroBlockEnd": {
      "type": "string",
      "x-intellij-html-description": "<p>A regular expression matching macros that end a block.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=MacroBlockEnd%20('>Documentation</a>\n"
    },
    "MaxEmptyLinesToKeep": {
      "type": "number",
      "x-intellij-html-description": "<p>The maximum number of consecutive empty lines to keep.\n<p>.. code-block:: c++\n<p>   MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n   int f() {                              int f() {\n     int = 1;                                 int i = 1;\n                                              i = foo();\n     i = foo();                               return i;\n                                          }\n     return i;\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=MaxEmptyLinesToKeep%20('>Documentation</a>\n"
    },
    "NamespaceIndentation": {
      "type": "string",
      "enum": [
        "None",
        "Inner",
        "All"
      ],
      "x-intellij-enum-metadata": {
        "None": {
          "description": "Don't indent in namespaces."
        },
        "Inner": {
          "description": "Indent only in inner namespaces (nested in other namespaces)."
        },
        "All": {
          "description": "Indent in all namespaces."
        }
      },
      "x-intellij-html-description": "<p>The indentation used for namespaces.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=NamespaceIndentation%20('>Documentation</a>\n"
    },
    "NamespaceMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of macros which are used to open namespace blocks.\n<p>These are expected to be macros of the form:\n<p>.. code-block:: c++\n<p>  NAMESPACE(<namespace-name>, ...) {\n    <namespace-content>\n  }\n<p>For example: TESTSUITE<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=NamespaceMacros%20('>Documentation</a>\n"
    },
    "ObjCBinPackProtocolList": {
      "type": "string",
      "enum": [
        "Auto",
        "Always",
        "Never"
      ],
      "x-intellij-enum-metadata": {
        "Auto": {
          "description": "Automatically determine parameter bin-packing behavior."
        },
        "Always": {
          "description": "Always bin-pack parameters."
        },
        "Never": {
          "description": "Never bin-pack parameters."
        }
      },
      "x-intellij-html-description": "<p>Controls bin-packing Objective-C protocol conformance list\nitems into as few lines as possible when they go over ``ColumnLimit``.\n<p>If ``Auto`` (the default), delegates to the value in\n``BinPackParameters``. If that is ``true``, bin-packs Objective-C\nprotocol conformance list items into as few lines as possible\nwhenever they go over ``ColumnLimit``.\n<p>If ``Always``, always bin-packs Objective-C protocol conformance\nlist items into as few lines as possible whenever they go over\n``ColumnLimit``.\n<p>If ``Never``, lays out Objective-C protocol conformance list items\nonto individual lines whenever they go over ``ColumnLimit``.\n<p>\n.. code-block:: objc\n<p>   Always (or Auto, if BinPackParameters=true):\n   @interface ccccccccccccc () <\n       ccccccccccccc, ccccccccccccc,\n       ccccccccccccc, ccccccccccccc> {\n   }\n<p>   Never (or Auto, if BinPackParameters=false):\n   @interface ddddddddddddd () <\n       ddddddddddddd,\n       ddddddddddddd,\n       ddddddddddddd,\n       ddddddddddddd> {\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ObjCBinPackProtocolList%20('>Documentation</a>\n"
    },
    "ObjCBlockIndentWidth": {
      "type": "number",
      "x-intellij-html-description": "<p>The number of characters to use for indentation of ObjC blocks.\n<p>.. code-block:: objc\n<p>   ObjCBlockIndentWidth: 4\n<p>   [operation setCompletionBlock:^{\n       [self onOperationDone];\n   }];<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ObjCBlockIndentWidth%20('>Documentation</a>\n"
    },
    "ObjCBreakBeforeNestedBlockParam": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Break parameters list into lines when there is nested block\nparameters in a function call.\n<p>.. code-block:: c++\n<p>  false:\n   - (void)_aMethod\n   {\n       [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n       *u, NSNumber *v) {\n           u = c;\n       }]\n   }\n   true:\n   - (void)_aMethod\n   {\n      [self.test1 t:self\n                   w:self\n          callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n               u = c;\n           }]\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ObjCBreakBeforeNestedBlockParam%20('>Documentation</a>\n"
    },
    "ObjCSpaceAfterProperty": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Add a space after ``@property`` in Objective-C, i.e. use\n``@property (readonly)`` instead of ``@property(readonly)``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ObjCSpaceAfterProperty%20('>Documentation</a>\n"
    },
    "ObjCSpaceBeforeProtocolList": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Add a space in front of an Objective-C protocol list, i.e. use\n``Foo <Protocol>`` instead of ``Foo<Protocol>``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ObjCSpaceBeforeProtocolList%20('>Documentation</a>\n"
    },
    "PPIndentWidth": {
      "type": "number",
      "x-intellij-html-description": "<p>The number of columns to use for indentation of preprocessor statements.\nWhen set to -1 (default) ``IndentWidth`` is used also for preprocessor\nstatements.\n<p>.. code-block:: c++\n<p>   PPIndentWidth: 1\n<p>   #ifdef __linux__\n   # define FOO\n   #else\n   # define BAR\n   #endif<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PPIndentWidth%20('>Documentation</a>\n"
    },
    "PackConstructorInitializers": {
      "type": "string",
      "enum": [
        "Never",
        "BinPack",
        "CurrentLine",
        "NextLine"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Always put each constructor initializer on its own line."
        },
        "BinPack": {
          "description": "Bin-pack constructor initializers."
        },
        "CurrentLine": {
          "description": "Put all constructor initializers on the current line if they fit."
        },
        "NextLine": {
          "description": "Same as ``PCIS_CurrentLine`` except that if all constructor initializers"
        }
      },
      "x-intellij-html-description": "<p>The pack constructor initializers style to use.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PackConstructorInitializers%20('>Documentation</a>\n"
    },
    "PenaltyBreakAssignment": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for breaking around an assignment operator.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakAssignment%20('>Documentation</a>\n"
    },
    "PenaltyBreakBeforeFirstCallParameter": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for breaking a function call after ``call(``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakBeforeFirstCallParameter%20('>Documentation</a>\n"
    },
    "PenaltyBreakComment": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for each line break introduced inside a comment.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakComment%20('>Documentation</a>\n"
    },
    "PenaltyBreakFirstLessLess": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for breaking before the first ``<<``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakFirstLessLess%20('>Documentation</a>\n"
    },
    "PenaltyBreakOpenParenthesis": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for breaking after ``(``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakOpenParenthesis%20('>Documentation</a>\n"
    },
    "PenaltyBreakString": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for each line break introduced inside a string literal.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakString%20('>Documentation</a>\n"
    },
    "PenaltyBreakTemplateDeclaration": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for breaking after template declaration.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyBreakTemplateDeclaration%20('>Documentation</a>\n"
    },
    "PenaltyExcessCharacter": {
      "type": "number",
      "x-intellij-html-description": "<p>The penalty for each character outside of the column limit.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyExcessCharacter%20('>Documentation</a>\n"
    },
    "PenaltyIndentedWhitespace": {
      "type": "number",
      "x-intellij-html-description": "<p>Penalty for each character of whitespace indentation\n(counted relative to leading non-whitespace column).<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyIndentedWhitespace%20('>Documentation</a>\n"
    },
    "PenaltyReturnTypeOnItsOwnLine": {
      "type": "number",
      "x-intellij-html-description": "<p>Penalty for putting the return type of a function onto its own line.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PenaltyReturnTypeOnItsOwnLine%20('>Documentation</a>\n"
    },
    "PointerAlignment": {
      "type": "string",
      "enum": [
        "Left",
        "Right",
        "Middle"
      ],
      "x-intellij-enum-metadata": {
        "Left": {
          "description": "Align pointer to the left."
        },
        "Right": {
          "description": "Align pointer to the right."
        },
        "Middle": {
          "description": "Align pointer in the middle."
        }
      },
      "x-intellij-html-description": "<p>Pointer and reference alignment style.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=PointerAlignment%20('>Documentation</a>\n"
    },
    "QualifierAlignment": {
      "type": "string",
      "enum": [
        "Leave",
        "Left",
        "Right",
        "Custom"
      ],
      "x-intellij-enum-metadata": {
        "Leave": {
          "description": "Don't change specifiers/qualifiers to either Left or Right alignment"
        },
        "Left": {
          "description": "Change specifiers/qualifiers to be left-aligned."
        },
        "Right": {
          "description": "Change specifiers/qualifiers to be right-aligned."
        },
        "Custom": {
          "description": "Change specifiers/qualifiers to be aligned based on ``QualifierOrder``."
        }
      },
      "x-intellij-html-description": "<p>Different ways to arrange specifiers and qualifiers (e.g. const/volatile).\n<p>.. warning:: \n<p> Setting ``QualifierAlignment``  to something other than `Leave`, COULD\n lead to incorrect code formatting due to incorrect decisions made due to\n clang-formats lack of complete semantic information.\n As such extra care should be taken to review code changes made by the use\n of this option.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=QualifierAlignment%20('>Documentation</a>\n"
    },
    "QualifierOrder": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>The order in which the qualifiers appear.\nOrder is an array that can contain any of the following:\n<p>  * const\n  * inline\n  * static\n  * friend\n  * constexpr\n  * volatile\n  * restrict\n  * type\n<p>Note: it MUST contain 'type'.\nItems to the left of 'type' will be placed to the left of the type and\naligned in the order supplied. Items to the right of 'type' will be placed\nto the right of the type and aligned in the order supplied.\n<p>\n.. code-block:: yaml\n<p>  QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=QualifierOrder%20('>Documentation</a>\n"
    },
    "RawStringFormats": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "Language": {
            "x-intellij-html-description": "The language of this raw string.",
            "type": "string",
            "enum": [
              "None",
              "Cpp",
              "CSharp",
              "Java",
              "JavaScript",
              "ObjC",
              "Proto",
              "TableGen",
              "TextProto"
            ]
          },
          "Delimiters": {
            "x-intellij-html-description": "A list of raw string delimiters that match this language.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "EnclosingFunctions": {
            "x-intellij-html-description": "A list of enclosing function names that match this language.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "BasedOnStyle": {
            "x-intellij-html-description": "The style name on which this raw string format is based on. If not specified, the raw string format is based on the style that this format is based on.",
            "type": "string",
            "enum": [
              "LLVM",
              "Google",
              "Chromium",
              "Mozilla",
              "WebKit",
              "Microsoft",
              "GNU",
              "InheritParentConfig"
            ],
            "x-intellij-enum-metadata": {
              "LLVM": {
                "description": "A style complying with the LLVM coding standards"
              },
              "Google": {
                "description": "A style complying with Google's C++ style guide"
              },
              "Chromium": {
                "description": "A style complying with Chromium's style guide"
              },
              "Mozilla": {
                "description": "A style complying with Mozilla's style guide"
              },
              "WebKit": {
                "description": "A style complying with WebKit's style guide"
              },
              "Microsoft": {
                "description": "A style complying with Microsoft's style guide"
              },
              "GNU": {
                "description": "A style complying with the GNU coding standards"
              }
            }
          },
          "CanonicalDelimiter": {
            "x-intellij-html-description": "The canonical delimiter for this language.",
            "type": "string"
          }
        }
      },
      "x-intellij-html-description": "<p>Defines hints for detecting supported languages code blocks in raw\nstrings.\n<p>A raw string with a matching delimiter or a matching enclosing function\nname will be reformatted assuming the specified language based on the\nstyle for that language defined in the .clang-format file. If no style has\nbeen defined in the .clang-format file for the specific language, a\npredefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\nfound, the formatting is based on llvm style. A matching delimiter takes\nprecedence over a matching enclosing function name for determining the\nlanguage of the raw string contents.\n<p>If a canonical delimiter is specified, occurrences of other delimiters for\nthe same language will be updated to the canonical if possible.\n<p>There should be at most one specification per language and each delimiter\nand enclosing function should not occur in multiple specifications.\n<p>To configure this in the .clang-format file, use:\n<p>.. code-block:: yaml\n<p>  RawStringFormats:\n    - Language: TextProto\n        Delimiters:\n          - 'pb'\n          - 'proto'\n        EnclosingFunctions:\n          - 'PARSE_TEXT_PROTO'\n        BasedOnStyle: google\n    - Language: Cpp\n        Delimiters:\n          - 'cc'\n          - 'cpp'\n        BasedOnStyle: llvm\n        CanonicalDelimiter: 'cc'<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=RawStringFormats%20('>Documentation</a>\n"
    },
    "ReferenceAlignment": {
      "type": "string",
      "enum": [
        "Pointer",
        "Left",
        "Right",
        "Middle"
      ],
      "x-intellij-enum-metadata": {
        "Pointer": {
          "description": "Align reference like ``PointerAlignment``."
        },
        "Left": {
          "description": "Align reference to the left."
        },
        "Right": {
          "description": "Align reference to the right."
        },
        "Middle": {
          "description": "Align reference in the middle."
        }
      },
      "x-intellij-html-description": "<p>Reference alignment style (overrides ``PointerAlignment`` for\nreferences).<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ReferenceAlignment%20('>Documentation</a>\n"
    },
    "ReflowComments": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, clang-format will attempt to re-flow comments. That is it\nwill touch a comment and *reflow* long comments into new lines, trying to\nobey the ``ColumnLimit``.\n<p>.. code-block:: c++\n<p>   false:\n   // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n   /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n<p>   true:\n   // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n   // information\n   /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n    * information */<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ReflowComments%20('>Documentation</a>\n"
    },
    "RemoveBracesLLVM": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Remove optional braces of control statements (``if``, ``else``, ``for``,\nand ``while``) in C++ according to the LLVM coding style.\n<p>.. warning:: \n<p> This option will be renamed and expanded to support other styles.\n<p>.. warning:: \n<p> Setting this option to `true` could lead to incorrect code formatting due\n to clang-format's lack of complete semantic information. As such, extra\n care should be taken to review code changes made by this option.\n<p>.. code-block:: c++\n<p>  false:                                     true:\n<p>  if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))\n    handleFunctionDecl(D);                     handleFunctionDecl(D);\n  } else if (isa<VarDecl>(D)) {              else if (isa<VarDecl>(D))\n    handleVarDecl(D);                          handleVarDecl(D);\n  }\n<p>  if (isa<VarDecl>(D)) {             vs.     if (isa<VarDecl>(D)) {\n    for (auto *A : D.attrs()) {                for (auto *A : D.attrs())\n      if (shouldProcessAttr(A)) {                if (shouldProcessAttr(A))\n        handleAttr(A);                             handleAttr(A);\n      }                                      }\n    }\n  }\n<p>  if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))\n    for (auto *A : D.attrs()) {                for (auto *A : D.attrs())\n      handleAttr(A);                             handleAttr(A);\n    }\n  }\n<p>  if (auto *D = (T)(D)) {            vs.     if (auto *D = (T)(D)) {\n    if (shouldProcess(D)) {                    if (shouldProcess(D))\n      handleVarDecl(D);                          handleVarDecl(D);\n    } else {                                   else\n      markAsIgnored(D);                          markAsIgnored(D);\n    }                                        }\n  }\n<p>  if (a) {                           vs.     if (a)\n    b();                                       b();\n  } else {                                   else if (c)\n    if (c) {                                   d();\n      d();                                   else\n    } else {                                   e();\n      e();\n    }\n  }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=RemoveBracesLLVM%20('>Documentation</a>\n"
    },
    "RemoveSemicolon": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Remove semicolons after the closing brace of a non-empty function.\n<p>.. warning:: \n<p> Setting this option to `true` could lead to incorrect code formatting due\n to clang-format's lack of complete semantic information. As such, extra\n care should be taken to review code changes made by this option.\n<p>.. code-block:: c++\n<p>  false:                                     true:\n<p>  int max(int a, int b) {                    int max(int a, int b) {\n    return a > b ? a : b;                      return a > b ? a : b;\n  };                                         }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=RemoveSemicolon%20('>Documentation</a>\n"
    },
    "RequiresClausePosition": {
      "type": "string",
      "enum": [
        "OwnLine",
        "WithPreceding",
        "WithFollowing",
        "SingleLine"
      ],
      "x-intellij-enum-metadata": {
        "OwnLine": {
          "description": "Always put the ``requires`` clause on its own line."
        },
        "WithPreceding": {
          "description": "Try to put the clause together with the preceding part of a declaration."
        },
        "WithFollowing": {
          "description": "Try to put the ``requires`` clause together with the class or function"
        },
        "SingleLine": {
          "description": "Try to put everything in the same line if possible. Otherwise normal"
        }
      },
      "x-intellij-html-description": "<p>The position of the ``requires`` clause.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=RequiresClausePosition%20('>Documentation</a>\n"
    },
    "RequiresExpressionIndentation": {
      "type": "string",
      "enum": [
        "OuterScope",
        "Keyword"
      ],
      "x-intellij-enum-metadata": {
        "OuterScope": {
          "description": "Align requires expression body relative to the indentation level of the"
        },
        "Keyword": {
          "description": "Align requires expression body relative to the `requires` keyword."
        }
      },
      "x-intellij-html-description": "<p>The indentation used for requires expression bodies.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=RequiresExpressionIndentation%20('>Documentation</a>\n"
    },
    "SeparateDefinitionBlocks": {
      "type": "string",
      "enum": [
        "Leave",
        "Always",
        "Never"
      ],
      "x-intellij-enum-metadata": {
        "Leave": {
          "description": "Leave definition blocks as they are."
        },
        "Always": {
          "description": "Insert an empty line between definition blocks."
        },
        "Never": {
          "description": "Remove any empty line between definition blocks."
        }
      },
      "x-intellij-html-description": "<p>Specifies the use of empty lines to separate definition blocks, including\nclasses, structs, enums, and functions.\n<p>.. code-block:: c++\n<p>   Never                  v.s.     Always\n   #include <cstring>              #include <cstring>\n   struct Foo {\n     int a, b, c;                  struct Foo {\n   };                                int a, b, c;\n   namespace Ns {                  };\n   class Bar {\n   public:                         namespace Ns {\n     struct Foobar {               class Bar {\n       int a;                      public:\n       int b;                        struct Foobar {\n     };                                int a;\n   private:                            int b;\n     int t;                          };\n     int method1() {\n       // ...                      private:\n     }                               int t;\n     enum List {\n       ITEM1,                        int method1() {\n       ITEM2                           // ...\n     };                              }\n     template<typename T>\n     int method2(T x) {              enum List {\n       // ...                          ITEM1,\n     }                                 ITEM2\n     int i, j, k;                    };\n     int method3(int par) {\n       // ...                        template<typename T>\n     }                               int method2(T x) {\n   };                                  // ...\n   class C {};                       }\n   }\n                                     int i, j, k;\n<p>                                     int method3(int par) {\n                                       // ...\n                                     }\n                                   };\n<p>                                   class C {};\n                                   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SeparateDefinitionBlocks%20('>Documentation</a>\n"
    },
    "ShortNamespaceLines": {
      "type": "number",
      "x-intellij-html-description": "<p>The maximal number of unwrapped lines that a short namespace spans.\nDefaults to 1.\n<p>This determines the maximum length of short namespaces by counting\nunwrapped lines (i.e. containing neither opening nor closing\nnamespace brace) and makes \"FixNamespaceComments\" omit adding\nend comments for those.\n<p>.. code-block:: c++\n<p>   ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n   namespace a {                      namespace a {\n     int foo;                           int foo;\n   }                                  } // namespace a\n<p>   ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n   namespace b {                      namespace b {\n     int foo;                           int foo;\n     int bar;                           int bar;\n   } // namespace b                   } // namespace b<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=ShortNamespaceLines%20('>Documentation</a>\n"
    },
    "SortIncludes": {
      "type": "string",
      "enum": [
        "Never",
        "CaseSensitive",
        "CaseInsensitive"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Includes are never sorted."
        },
        "CaseSensitive": {
          "description": "Includes are sorted in an ASCIIbetical or case sensitive fashion."
        },
        "CaseInsensitive": {
          "description": "Includes are sorted in an alphabetical or case insensitive fashion."
        }
      },
      "x-intellij-html-description": "<p>Controls if and how clang-format will sort ``#includes``.\nIf ``Never``, includes are never sorted.\nIf ``CaseInsensitive``, includes are sorted in an ASCIIbetical or case\ninsensitive fashion.\nIf ``CaseSensitive``, includes are sorted in an alphabetical or case\nsensitive fashion.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SortIncludes%20('>Documentation</a>\n"
    },
    "SortJavaStaticImport": {
      "type": "string",
      "enum": [
        "Before",
        "After"
      ],
      "x-intellij-enum-metadata": {
        "Before": {
          "description": "Static imports are placed before non-static imports."
        },
        "After": {
          "description": "Static imports are placed after non-static imports."
        }
      },
      "x-intellij-html-description": "<p>When sorting Java imports, by default static imports are placed before\nnon-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\nstatic imports are placed after non-static imports.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SortJavaStaticImport%20('>Documentation</a>\n"
    },
    "SortUsingDeclarations": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, clang-format will sort using declarations.\n<p>The order of using declarations is defined as follows:\nSplit the strings by \"::\" and discard any initial empty strings. The last\nelement of each list is a non-namespace name; all others are namespace\nnames. Sort the lists of names lexicographically, where the sort order of\nindividual names is that all non-namespace names come before all namespace\nnames, and within those groups, names are in case-insensitive\nlexicographic order.\n<p>.. code-block:: c++\n<p>   false:                                 true:\n   using std::cout;               vs.     using std::cin;\n   using std::cin;                        using std::cout;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SortUsingDeclarations%20('>Documentation</a>\n"
    },
    "SpaceAfterCStyleCast": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, a space is inserted after C style casts.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   (int) i;                       vs.     (int)i;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceAfterCStyleCast%20('>Documentation</a>\n"
    },
    "SpaceAfterLogicalNot": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, a space is inserted after the logical not operator (``!``).\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   ! someExpression();            vs.     !someExpression();<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceAfterLogicalNot%20('>Documentation</a>\n"
    },
    "SpaceAfterTemplateKeyword": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, a space will be inserted after the 'template' keyword.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   template <int> void foo();     vs.     template<int> void foo();<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceAfterTemplateKeyword%20('>Documentation</a>\n"
    },
    "SpaceAroundPointerQualifiers": {
      "type": "string",
      "enum": [
        "Default",
        "Before",
        "After",
        "Both"
      ],
      "x-intellij-enum-metadata": {
        "Default": {
          "description": "Don't ensure spaces around pointer qualifiers and use PointerAlignment"
        },
        "Before": {
          "description": "Ensure that there is a space before pointer qualifiers."
        },
        "After": {
          "description": "Ensure that there is a space after pointer qualifiers."
        },
        "Both": {
          "description": "Ensure that there is a space both before and after pointer qualifiers."
        }
      },
      "x-intellij-html-description": "<p>Defines in which cases to put a space before or after pointer qualifiers<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceAroundPointerQualifiers%20('>Documentation</a>\n"
    },
    "SpaceBeforeAssignmentOperators": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, spaces will be removed before assignment operators.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   int a = 5;                     vs.     int a= 5;\n   a += 42;                               a+= 42;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeAssignmentOperators%20('>Documentation</a>\n"
    },
    "SpaceBeforeCaseColon": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, spaces will be removed before case colon.\n<p>.. code-block:: c++\n<p>  true:                                   false\n  switch (x) {                    vs.     switch (x) {\n    case 1 : break;                         case 1: break;\n  }                                       }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeCaseColon%20('>Documentation</a>\n"
    },
    "SpaceBeforeCpp11BracedList": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, a space will be inserted before a C++11 braced list\nused to initialize an object (after the preceding identifier or type).\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   Foo foo { bar };               vs.     Foo foo{ bar };\n   Foo {};                                Foo{};\n   vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n   new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeCpp11BracedList%20('>Documentation</a>\n"
    },
    "SpaceBeforeCtorInitializerColon": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, spaces will be removed before constructor initializer\ncolon.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeCtorInitializerColon%20('>Documentation</a>\n"
    },
    "SpaceBeforeInheritanceColon": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, spaces will be removed before inheritance colon.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   class Foo : Bar {}             vs.     class Foo: Bar {}<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeInheritanceColon%20('>Documentation</a>\n"
    },
    "SpaceBeforeParens": {
      "type": "string",
      "enum": [
        "Never",
        "ControlStatements",
        "ControlStatementsExceptControlMacros",
        "NonEmptyParentheses",
        "Always",
        "Custom"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Never put a space before opening parentheses."
        },
        "ControlStatements": {
          "description": "Put a space before opening parentheses only after control statement"
        },
        "ControlStatementsExceptControlMacros": {
          "description": "Same as ``SBPO_ControlStatements`` except this option doesn't apply to"
        },
        "NonEmptyParentheses": {
          "description": "Put a space before opening parentheses only if the parentheses are not"
        },
        "Always": {
          "description": "Always put a space before opening parentheses, except when it's"
        },
        "Custom": {
          "description": "Configure each individual space before parentheses in"
        }
      },
      "x-intellij-html-description": "<p>Defines in which cases to put a space before opening parentheses.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeParens%20('>Documentation</a>\n"
    },
    "SpaceBeforeParensOptions": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "AfterControlStatements": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put space betwee control statement keywords\n(for/if/while...) and opening parentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   if (...) {}                     vs.    if(...) {}"
        },
        "AfterForeachMacros": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put space between foreach macros and opening parentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   FOREACH (...)                   vs.    FOREACH(...)\n     <loop-body>                            <loop-body>"
        },
        "AfterFunctionDeclarationName": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put a space between function declaration name and opening\nparentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   void f ();                      vs.    void f();"
        },
        "AfterFunctionDefinitionName": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put a space between function definition name and opening\nparentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   void f () {}                    vs.    void f() {}"
        },
        "AfterIfMacros": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put space between if macros and opening parentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   IF (...)                        vs.    IF(...)\n     <conditional-body>                     <conditional-body>"
        },
        "AfterOverloadedOperator": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put a space between operator overloading and opening\nparentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   void operator++ (int a);        vs.    void operator++(int a);\n   object.operator++ (10);                object.operator++(10);"
        },
        "AfterRequiresInClause": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put space between requires keyword in a requires clause and\nopening parentheses, if there is one.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   template<typename T>            vs.    template<typename T>\n   requires (A<T> && B<T>)                requires(A<T> && B<T>)\n   ...                                    ..."
        },
        "AfterRequiresInExpression": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put space between requires keyword in a requires expression\nand opening parentheses.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   template<typename T>            vs.    template<typename T>\n   concept C = requires (T t) {           concept C = requires(T t) {\n                 ...                                    ...\n               }                                      }"
        },
        "BeforeNonEmptyParentheses": {
          "type": "boolean",
          "x-intellij-html-description": "<p>If ``true``, put a space before opening parentheses only if the\nparentheses are not empty.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   void f (int a);                 vs.    void f();\n   f (a);                                 f();"
        }
      },
      "x-intellij-html-description": "<p>Control of individual space before parentheses.\n<p>If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify\nhow each individual space before parentheses case should be handled.\nOtherwise, this is ignored.\n<p>.. code-block:: yaml\n<p>  # Example of usage:\n  SpaceBeforeParens: Custom\n  SpaceBeforeParensOptions:\n    AfterControlStatements: true\n    AfterFunctionDefinitionName: true<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeParensOptions%20('>Documentation</a>\n"
    },
    "SpaceBeforeRangeBasedForLoopColon": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``false``, spaces will be removed before range-based for loop\ncolon.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   for (auto v : values) {}       vs.     for(auto v: values) {}<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeRangeBasedForLoopColon%20('>Documentation</a>\n"
    },
    "SpaceBeforeSquareBrackets": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces will be before  ``[``.\nLambdas will not be affected. Only the first ``[`` will get a space added.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   int a [5];                    vs.      int a[5];\n   int a [5][5];                 vs.      int a[5][5];<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceBeforeSquareBrackets%20('>Documentation</a>\n"
    },
    "SpaceInEmptyBlock": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces will be inserted into ``{}``.\n<p>.. code-block:: c++\n<p>   true:                                false:\n   void f() { }                   vs.   void f() {}\n   while (true) { }                     while (true) {}<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceInEmptyBlock%20('>Documentation</a>\n"
    },
    "SpaceInEmptyParentheses": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces may be inserted into ``()``.\n<p>.. code-block:: c++\n<p>   true:                                false:\n   void f( ) {                    vs.   void f() {\n     int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n     if (true) {                          if (true) {\n       f( );                                f();\n     }                                    }\n   }                                    }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpaceInEmptyParentheses%20('>Documentation</a>\n"
    },
    "SpacesBeforeTrailingComments": {
      "type": "number",
      "x-intellij-html-description": "<p>The number of spaces before trailing line comments\n(``//`` - comments).\n<p>This does not affect trailing block comments (``/*`` - comments) as\nthose commonly have different usage patterns and a number of special\ncases.\n<p>.. code-block:: c++\n<p>   SpacesBeforeTrailingComments: 3\n   void f() {\n     if (true) {   // foo1\n       f();        // bar\n     }             // foo\n   }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesBeforeTrailingComments%20('>Documentation</a>\n"
    },
    "SpacesInAngles": {
      "type": "string",
      "enum": [
        "Never",
        "Always",
        "Leave"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Remove spaces after ````."
        },
        "Always": {
          "description": "Add spaces after ````."
        },
        "Leave": {
          "description": "Keep a single space after ```` if any spaces were"
        }
      },
      "x-intellij-html-description": "<p>The SpacesInAnglesStyle to use for template argument lists.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInAngles%20('>Documentation</a>\n"
    },
    "SpacesInCStyleCastParentheses": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces may be inserted into C style casts.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   x = ( int32 )y                 vs.     x = (int32)y<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInCStyleCastParentheses%20('>Documentation</a>\n"
    },
    "SpacesInConditionalStatement": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces will be inserted around if/for/switch/while\nconditions.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   if ( a )  { ... }              vs.     if (a) { ... }\n   while ( i < 5 )  { ... }               while (i < 5) { ... }<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInConditionalStatement%20('>Documentation</a>\n"
    },
    "SpacesInContainerLiterals": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces are inserted inside container literals (e.g.\nObjC and Javascript array and dict literals).\n<p>.. code-block:: js\n<p>   true:                                  false:\n   var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n   f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInContainerLiterals%20('>Documentation</a>\n"
    },
    "SpacesInLineCommentPrefix": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Minimum": {
          "type": "number",
          "x-intellij-html-description": "<p>The minimum number of spaces at the start of the comment."
        },
        "Maximum": {
          "type": "number",
          "x-intellij-html-description": "<p>The maximum number of spaces at the start of the comment."
        }
      },
      "x-intellij-html-description": "<p>How many spaces are allowed at the start of a line comment. To disable the\nmaximum set it to ``-1``, apart from that the maximum takes precedence\nover the minimum.\n<p>.. code-block:: c++\n<p>  Minimum = 1\n  Maximum = -1\n  // One space is forced\n<p>  //  but more spaces are possible\n<p>  Minimum = 0\n  Maximum = 0\n  //Forces to start every comment directly after the slashes\n<p>Note that in line comment sections the relative indent of the subsequent\nlines is kept, that means the following:\n<p>.. code-block:: c++\n<p>  before:                                   after:\n  Minimum: 1\n  //if (b) {                                // if (b) {\n  //  return true;                          //   return true;\n  //}                                       // }\n<p>  Maximum: 0\n  /// List:                                 ///List:\n  ///  - Foo                                /// - Foo\n  ///    - Bar                              ///   - Bar\n<p>This option has only effect if ``ReflowComments`` is set to ``true``.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInLineCommentPrefix%20('>Documentation</a>\n"
    },
    "SpacesInParentheses": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces will be inserted after ``(`` and before ``)``.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInParentheses%20('>Documentation</a>\n"
    },
    "SpacesInSquareBrackets": {
      "type": "boolean",
      "x-intellij-html-description": "<p>If ``true``, spaces will be inserted after ``[`` and before ``]``.\nLambdas without arguments or unspecified size array declarations will not\nbe affected.\n<p>.. code-block:: c++\n<p>   true:                                  false:\n   int a[ 5 ];                    vs.     int a[5];\n   std::unique_ptr<int[]> foo() {} // Won't be affected<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=SpacesInSquareBrackets%20('>Documentation</a>\n"
    },
    "Standard": {
      "type": "string",
      "enum": [
        "Cpp03",
        "Cpp11",
        "Cpp14",
        "Cpp17",
        "Cpp20",
        "Latest",
        "Auto"
      ],
      "x-intellij-enum-metadata": {
        "Cpp03": {
          "description": "Parse and format as C++03."
        },
        "Cpp11": {
          "description": "Parse and format as C++11."
        },
        "Cpp14": {
          "description": "Parse and format as C++14."
        },
        "Cpp17": {
          "description": "Parse and format as C++17."
        },
        "Cpp20": {
          "description": "Parse and format as C++20."
        },
        "Latest": {
          "description": "Parse and format using the latest supported language version."
        },
        "Auto": {
          "description": "Automatic detection based on the input."
        }
      },
      "x-intellij-html-description": "<p>Parse and format C++ constructs compatible with this standard.\n<p>.. code-block:: c++\n<p>   c++03:                                 latest:\n   vector<set<int> > x;           vs.     vector<set<int>> x;<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=Standard%20('>Documentation</a>\n"
    },
    "StatementAttributeLikeMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>Macros which are ignored in front of a statement, as if they were an\nattribute. So that they are not parsed as identifier, for example for Qts\nemit.\n<p>.. code-block:: c++\n<p>  AlignConsecutiveDeclarations: true\n  StatementAttributeLikeMacros: []\n  unsigned char data = 'x';\n  emit          signal(data); // This is parsed as variable declaration.\n<p>  AlignConsecutiveDeclarations: true\n  StatementAttributeLikeMacros: [emit]\n  unsigned char data = 'x';\n  emit signal(data); // Now it's fine again.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=StatementAttributeLikeMacros%20('>Documentation</a>\n"
    },
    "StatementMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of macros that should be interpreted as complete\nstatements.\n<p>Typical macros are expressions, and require a semi-colon to be\nadded; sometimes this is not the case, and this allows to make\nclang-format aware of such cases.\n<p>For example: Q_UNUSED<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=StatementMacros%20('>Documentation</a>\n"
    },
    "TabWidth": {
      "type": "number",
      "x-intellij-html-description": "<p>The number of columns used for tab stops.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=TabWidth%20('>Documentation</a>\n"
    },
    "TypenameMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of macros that should be interpreted as type declarations\ninstead of as function calls.\n<p>These are expected to be macros of the form:\n<p>.. code-block:: c++\n<p>  STACK_OF(...)\n<p>In the .clang-format configuration file, this can be configured like:\n<p>.. code-block:: yaml\n<p>  TypenameMacros: ['STACK_OF', 'LIST']\n<p>For example: OpenSSL STACK_OF, BSD LIST_ENTRY.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=TypenameMacros%20('>Documentation</a>\n"
    },
    "UseCRLF": {
      "type": "boolean",
      "x-intellij-html-description": "<p>Use ``\\r\\n`` instead of ``\\n`` for line breaks.\nAlso used as fallback if ``DeriveLineEnding`` is true.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=UseCRLF%20('>Documentation</a>\n"
    },
    "UseTab": {
      "type": "string",
      "enum": [
        "Never",
        "ForIndentation",
        "ForContinuationAndIndentation",
        "AlignWithSpaces",
        "Always"
      ],
      "x-intellij-enum-metadata": {
        "Never": {
          "description": "Never use tab."
        },
        "ForIndentation": {
          "description": "Use tabs only for indentation."
        },
        "ForContinuationAndIndentation": {
          "description": "Fill all leading whitespace with tabs, and use spaces for alignment that"
        },
        "AlignWithSpaces": {
          "description": "Use tabs for line continuation and indentation, and spaces for"
        },
        "Always": {
          "description": "Use tabs whenever we need to fill whitespace that spans at least from"
        }
      },
      "x-intellij-html-description": "<p>The way to use tab characters in the resulting file.<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=UseTab%20('>Documentation</a>\n"
    },
    "WhitespaceSensitiveMacros": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-intellij-html-description": "<p>A vector of macros which are whitespace-sensitive and should not\nbe touched.\n<p>These are expected to be macros of the form:\n<p>.. code-block:: c++\n<p>  STRINGIZE(...)\n<p>In the .clang-format configuration file, this can be configured like:\n<p>.. code-block:: yaml\n<p>  WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n<p>For example: BOOST_PP_STRINGIZE<p><a href='https://clang.llvm.org/docs/ClangFormatStyleOptions.html#:~:text=WhitespaceSensitiveMacros%20('>Documentation</a>\n"
    }
  }
}